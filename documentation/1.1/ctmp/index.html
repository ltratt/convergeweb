<%include file="../../../header.inc"/>

<%text>

<h1>Guide to compile-time meta-programming</h1>

Compile-Time Meta-Programming (CTMP) can be thought of as being a more powerful cousin of macros; formally, it is said to allow the user of a programming language a mechanism to interact with the compiler. Most commonly CTMP is used to allow the construction of arbitrary program fragments by user code. In essence Converge provides a mechanism to allow its concrete syntax to describe abstract syntax trees - conventionally called ITree's in Converge - which can then be then spliced into a source file.


<h2>First examples</h2>

<p>As a first example, consider this program which, at compile-time, computes the 30th entry in the Fibonacci sequence (computationally, a fairly expensive operation) and assigns it to the <code>fib30</code> variable:
<pre>
func fib(n):
  if n == 0:
    return 0
  elif n == 1:
    return 1
  else:
    return fib(n - 1) + fib(n - 2)

fib30 := $&lt;CEI::lift(fib(30))&gt;
</pre>
At run-time the variable <code>fib30</code> will have the value of 514229 directly assigned to it, negating the need to repeatedly calculate this particular entry in the Fibonacci sequence. The key feature of CTMP are <em>splice annotations</em> <code>$&lt;...&gt;</code>. A splice evaluates the expression within at compile-time (and before VM instruction generation), replacing the splice annotation itself with the AST resulting from its evaluation. This is achieved by creating a temporary module containing the splice expression in a function, compiling the temporary module into bytecode, injecting it into the running VM, and then evaluating the function therein. Since a splice must return an ITree, we need to convert a normal integer object into its ITree integer equivalent: in this example we <q>lift</q> the integer with the <code>CEI::lift</code> function.

<p>The following program is a slightly more involved example of CTMP, trivially adopted from its <a href="http://www.swen.uwaterloo.ca/~kczarnec/dagstuhl04.pdf">Template Haskell cousin</a>. <code>expand_power</code> recursively creates an expression that multiplies <code>n</code> <code>x</code> times; <code>mk_power</code> takes a parameter <code>n</code> and creates a function that takes a single argument <code>x</code> and calculates <em>x ^ n</em>; <code>power3</code> is a specific power function which calculates <em>n^3</em>:
<pre>
func expand_power(n, x):
  if n == 0:
    return [| 1 |]
  else:
    return [| $c{x} * $c{expand_power(n - 1, x)} |]

func mk_power(n):
  return [|
    func (&x):
      return $c{expand_power(n, [| &x |])}
  |]
  
power3 := $&lt;mk_power(3)&gt;
</pre>

<p>When the above example has been compiled into VM instructions, <code>power3</code> essentially looks as follows:
<pre>
power3 := func (x):
  return x * x * x * 1
</pre>

<p><em>Quasi-quoted</em> expressions <code>[| ... |]</code> build ITrees that represent the program code contained within them whilst ensuring that variable references respect Converge's lexical scoping rules.  <em>Insertions</em> <code>${...}</code> or <code>$c{...}</code> are used within quasi-quotes; they evaluate the expression within and copy the resulting ITree into the ITree being generated by the quasi-quote.


<h2>Differences from other approaches</h2>

<p>As the above examples show, by using the splicing and quasi-quoting mechanisms, users can generate code at compile-time. Many readers will be familiar with other macro and macro-esque approaches, and a brief comparison can be enlightening.

<p><q>Lexical</q> macros such as the C preprocessor are deal in string replacement, with little or no regard for the programming language they are dealing with. In such systems it is possible to create syntactically nonsensical programs, and to encounter difficult problems such as variable capture. Converge instead works at the abstract syntax tree level; it has little in common with such approaches.

<p><q>Traditional macro systems</q> are best exemplified by LISP. Converge ultimately traces its CTMP abilities back to LISP. As seen above, Converge uses normal functions for CTMP, and does not explicitly identify macros; instead macro calls (a.k.a splices) are explicitly identified. A number of other differences result from the fact that Converge has a modern, relatively rich, syntax compared to LISPs minimal syntax.


<hr>


<h2>Major features</h2>

The three major features of compile-time meta-programming are splicing, quasi-quoting, and insertion.

<h3>Splicing</h3>

The key part of the <q>powers</q> program is the splice annotation in the line <code>power3 := $&lt;mk_power(3)&gt;</code>. The splice tells the compiler to evaluate the expression between the chevrons at compile-time, and to include the result of that evaluation in the module for ultimate bytecode generation. In order to perform this evaluation, the compiler creates a temporary or <q>dummy</q> module which contains all the necessary definitions up to, but excluding, the definition the splice annotation is a part of; to this temporary module a new splice function (conventionally called <code>$$splice$$</code>) is added which contains a single expression <code>return <em>splice expr</code></em>. This temporary module is compiled to bytecode and injected into the running VM, whereupon the splice function is called. Thus the splice function `sees' all the necessary definitions prior to it in the module, and can call them freely -- there are no other limits on the splice expression. The splice function must return a valid ITree which the compiler uses in place of the splice annotation.

<p>Splice annotations within a file are executed strictly in order from top to bottom. There are three forms of splice:

Default splices <code>$<...></code> automatically rename any visible variables in the spliced in ITree to ensure that no variable capture is possible. Capturing splices <code>$c<...></code> do not rename variables, and thus potentially allow variable capture to occur. Pragma splices <code>$p<...></code> are different from either previous form in that they do not expect (and, in fact, ignore) any return result from the splice expression.

<table style="margin: 10px 10px 10px 10px">
<tr>
<td colspan="3">
<hr style="padding: 0; margin: 0">
</td>
</tr>
<tr style="font-weight: bold">
<td>Syntax</td>
<td style="padding-left: 20px">Type</td>
<td style="padding-left: 20px">Description</td>
</tr>
<tr>
<td colspan="3">
<hr style="padding: 0; margin: 0">
</td>
</tr>
<tr>
<td valign="top"><code>$<...></code></td>
<td valign="top" style="padding-left: 20px">Default</td>
<td style="padding-left: 20px">Default splicing evaluates an expression at compile-time and overwrites itself with the resulting ITree. Before it overwrites itself it renames all free and bound variables to fresh names meaning that variable capture is impossible with this type of splicing.</td>
</tr>
<tr>
<td valign="top"><code>$c<...></code></td>
<td valign="top" style="padding-left: 20px">Capturing</td>
<td style="padding-left: 20px">Capturing splicing evaluates an expression at compile-time and overwrites itself with the resulting ITree. Unlike default splicing it does not rename free or bound variables, and allows variable capture to occur.</td>
</tr>
</td>
</tr>
<tr>
<td valign="top"><code>$p<...></code></td>
<td valign="top" style="padding-left: 20px">Pragma</td>
<td style="padding-left: 20px">Pragma splices evaluates an expression and discards the result (if there is one - the expression may fail).</td>
</tr>
<tr>
<td colspan="3">
<hr style="padding: 0; margin: 0">
</td>
</tr>
</table>

All splice variants have a DSL block equivalent <code>$&lt;&lt;...&gt;&gt;</code>, <code>$c&lt;&lt;...&gt;&gt;</code>, and <code>$p&lt;&lt;...&gt;&gt;</code>.


<h3>Quasi-quoting</h3>

Quasi-quotes allow ITree's to be built using Converge's normal concrete syntax. Essentially a quasi-quoted expression evaluates to the ITree which represents the expression inside it. For example, whilst the raw Converge expression <code>4 + 2</code> prints <code>6</code> when evaluated, <code>[| 4 + 2 |]</code> evaluates to an ITree which prints out as <code>4 + 2</code>. Thus the quasi-quote mechanism constructs an ITree directly from the users' input - the exact nature of the ITree is of immaterial to the casual ITree user, who need not know that the resulting ITree is structured along the lines of <em>add(int(4), int(2))</em>.

<p>The quasi-quotes mechanism can be used to express ITree's of single expressions - in which case an individual ITree is returned - or a multi-line sequence of expressions - in which case a list of ITree's is returned.

<p>Note that Converge's splicing and quasi-quote mechanisms cancel each other out: <code>$&lt;[| <em>x</em> |]&gt;</code> is equivalent to <code><em>x</em></code> (though not necessarily vice versa if <code><em>x</em></code> does not contain a valid ITree).



<h2>Insertion</h2>

Insertions within quasi-quotes work very differently to splices (which occur outside quasi-quotes): the insertion expression itself does not force compile-time evaluation. Instead the insertion expression is essentially copied as-is into the code that the quasi-quotes transforms to. For example, the quasi-quoted expression <code>[| ${x} + 2 |]</code> leads to an ITree along the lines of <em>add(x, int(2))</em> -- the variable <code>x</code> in this case would need to contain a valid ITree. As this example shows, since splice annotations within quasi-quotes do not cause a change of meta-level, variable references do not cause staging concerns.

<p>There are three two forms of insertion. Default insertions <code>${...}</code> automatically rename any visible variables in the inserted ITree to ensure that no variable capture is possible. Capturing insertions <code>$c{...}</code> do not perform such renaming, and thus potentially allow variable capture to occur.

<p>This feature completes the cancelling out relationship between splicing and quasi-quoting: <code>[| ${<em>x</em>} |]</code> is equivalent to <code><em>x</em></code> (though not necessarily vice versa if <code><em>x</em></code> does not contain a valid ITree).


<hr>

<h2>Scoping rules</h2>

Compile-time meta-programming requires additions to Converge's scoping rules.


<h3>Scoping and splicing</h3>

<p>Evaluating a splice expression leads to a new <q>stage</q> in the compiler being executed. Converge's rules about which references can cross the staging boundary are simple: only references to top-level module definitions can be carried across the staging boundary. For example the following code is invalid since the variable <code>x</code> will only have a value at run-time, and hence is unavailable to the splice expression which is evaluated at compile-time:
<pre>
func g(...):
  return ...

func f(x):
  $&lt;g(x)&gt;
</pre>
Note the resulting error message:
<pre>
Error: Line 21, column 3: Unknown variable 'x'
</pre>
might initially seem somewhat confusing, since the user can clearly see <code>x</code>. However it makes rather more sense when one realises that the message is the result of compiling the following temporary module:
<pre>
func g(...):
  return ...

func $$splice$$(...):
  return g(x)
</pre>
Clearly when compiling this, there is no <code>x</code> variable in scope.


<h3>Scoping and quasi-quotes</h3>

The quasi-quote mechanism can be used to surround any Converge expression to allow the easy construction of ITree's. Quasi-quoting an expression has two important properties: it introduces a new scope (in identical fashion that a function defines a new scope), and it fully respects lexical scoping. Thus quasi-quotes allow users to easily avoid unintended variable capture.


<h4>Lexical scoping</h4>

Consider the following contrived example of module <code>A</code>:
<pre>
func x():
  return 4

func y():
  return [| x() * 2 |]
</pre>
and module <code>B</code>:
<pre>
import A, Sys

func x():
  return 2

func main():
  Sys::println($&lt;A::y()&gt;)
</pre>
The quasi-quotes mechanisms ensures that since the reference to <code>x</code> in the quasi-quoted expression in <code>A::y</code> refers lexically to <code>A::x</code>, that running module <code>B</code> prints out <code>8</code>. This example shows one of the reasons why Converge needs to be able to statically determine namespaces: since the reference of <code>x</code> in <code>A.y</code> is lexically resolved to the function <code>A::x</code>, the quasi-quotes mechanism can replace the simple reference with an <em>original name</em> that always evaluates to the slot <code>x</code> within the specific module <code>A</code> wherever it is spliced into, even if <code>A</code> is not in scope (or a different <code>A</code> is in scope) in the splice location.


<h4>Hygiene</h4>

<p>Variable capture is when splicing in an ITree could cause variables with the same name to inadvertently overwrite (or <q>capture</q>) each other. The default splicing mechanism in Converge prevents any variable capture occurring. However often one wishes certain variables to be captured. Consider the following contrived example which uses a capturing splice:
<pre>
func f():
  return [| x := 4 |]

func g():
  x := 10
  $c&lt;f()&gt;
  y := x
</pre>
What might one expect the value of <code>y</code> in function <code>g</code> to be after the value of <code>x</code> is assigned to it? A naive splicing of <code>f()</code> into <code>g</code> would mean that the <code>x</code> within <code>[| x := 4 |]</code> would be captured by the <code>x</code> already in <code>g</code> -- <code>y</code> would end with the value <code>4</code>. If this was the case, using the quasi-quote mechanism could potentially cause all sorts of unexpected interactions and problems. In order to solve this problem, not only is Converge able to statically determine namespaces, but variables can be alpha-renamed (essentially meaning that <code>x</code> can be changed consistently to <code>y</code> in a given scope) without affecting the programs semantics. This is a significant deviation from the Python heritage. The quasi-quotes mechanism determines all bound variables in a quasi-quoted expression, and preemptively alpha-renames each bound variable to a name which is invalid in the normal concrete syntax. In so doing, Converge guarantees that the user can not inadvertently cause variable clashes. All references to the variable within the quasi-quotes are updated similarly. Thus the <code>x</code> within <code>[| x := 4 |]</code> will not cause variable capture to occur, and the variable <code>y</code> in function <code>g</code> will be set to <code>10</code>.

<p>There is one exception: top-level definitions (all of which are assignments to a variable, although syntactic sugar generally obscures this fact) can not be alpha-renamed since this could lead to run-time <q>slot missing</q> exceptions being raised. Converge thus does not permit top-level definitions to be alpha-renamed.


<h4>Dynamic scoping</h4>

Sometimes the quasi-quote mechanisms automatic alpha-renaming of variables is not what is needed. For example consider a function <code>swap(x, y)</code> which should swap the values of two variables. In such a case, we <em>want</em> the result of the splice to capture the variables in the spliced environment. The following definition of <code>swap</code> expects to be passed two ITree's representing variables:
<pre>
func swap(x, y):
  return [|
    temp := $c{x}
    $c{x} := $c{y}
    $c{y} := temp
  |]
</pre>
It is initially tempting to try and use this function as follows:
<pre>
a := 10
b := 20
$c&lt;swap([| a |], [| b |])&gt;
</pre>
However this causes a staging error since the <code>a</code> and <code>b</code> in the quasi-quotes do not refer to a bound variable either inside or outside the quasi-quotes when the splice expression is evaluated (the latter would be invalid anyway, due to Converge's lifting rules; see later}). <code>swap</code> needs to be passed ITree's representing variable names, not references to variables. ITree's representing variable names can be constructed by the idiom <code>CEI::ivar(x)</code> where <code>x</code> is a string representing a variable name. When such a variable name is spliced into a quasi-quotes it will not be renamed, thereby allowing dynamic scoping. A correct call to <code>swap</code> thus looks as follows:
<pre>
$c&lt;swap(CEI::ivar(a), CEI::ivar("b"))&gt;
</pre>
In this case, the variable names constructed by the <code>CEI</code> interface are first spliced into the quasi-quotes in the <code>swap</code> function. The resulting ITree from the quasi-quotes is then spliced in place of the <code>swap</code> call, and the variable names dynamically capture the <code>a</code> and <code>b</code> variables.

<p>Dynamic scoping also tends to be useful when a quasi-quoted function is created piecemeal with many separate quasi-quote expressions. In such a case, variable references can only be resolved successfully when all the resulting ITree's are spliced together since references to the function's parameters and so on will not be determined until that point. Since it is highly tedious to continually write <code>CEI::ivar("foo")</code>, Converge provides the special syntax <code>&amp;foo</code> which is equivalent. Notice that this notation prefixes a variable <em>name</em> --- it has nothing to do with the value the variable contains. Using this syntax also allows <code>swap</code> to be called in the following less cumbersome fashion:
<pre>
$c&lt;swap([| &amp;a |], [| &amp;b |])&gt;
</pre>


<h4>Forward references and splicing</h4>

We saw earlier that when a splice annotation outside quasi-quotes is encountered, a temporary module is created which contains all the definitions up to, but excluding, the definition holding the splice annotation. This is a very useful feature since compile-time functions used only in one module can be kept in that module. However this introduces a real problem involving forward references (i.e. a reference to a definition defined later in the file). If a splice annotation is encountered and compiles a subset of the module, then some definitions involved in forward references may not be included: thus the temporary module will fail to compile, leading to the entire module not compiling. Worse still, the user is likely to be presented with a highly confusing error telling them that a particular reference is undefined when, as far as they are concerned, the definition is staring at them within their text editor.

<p>Consider the following contrived example:
<pre>
func f1():
  return [| 7 |]

func f2():
  x := f4()

func f3():
  return $&lt;f1()&gt;

func f4():
  pass
</pre>
If <code>f2</code> is included in the temporary module created when evaluating the splice annotation in <code>f3</code>, then the forward reference to <code>f4</code> will be unresolvable.

<p>Converge's solution to this problem is to include only the minimal needed subset of definitions in the temporary module; thus most forward references do not raise a compile-time error. When a splice annotation is encountered, the Converge compiler does not immediately create a temporary module. First it calculates the splice expressions' free variables; any previously encountered definition which has a name in the set of free variables is added to a set of definitions to include. These definitions themselves then have their free variables calculated, and again any previously encountered definition which has a name in the set of free variables is added to the set of definitions to include. This last step is repeated until an iteration adds no new definitions to the set. At this point, Converge then goes back in order over all previously encountered definitions, and if the definition is in the list of definitions to include, it is added to the temporary module (this last stage ensures that definitions are not reordered in the temporary module). Note also that free variables which genuinely do not refer to any definitions (i.e. a mistake on the part of the programmer) will pass through this scheme unmolested and will raise an appropriate error when the temporary module is compiled.

<p>Using this method, the temporary module that is created and evaluated for the example looks as follows:
<pre>
func f1():
  return [| 7 |]

func $$splice$$():
  return f1()
</pre>

There are thus no unresolvable forward references in this example. Notice that Converge's approach to the forward reference problem is not a completely general solution since some forward references (particularly those to definitions beyond a splice site) are inherently unresolvable. Converge's approach is intended to significantly reduce the problem to the point that any unresolvable references are the result of programmer error.


<h4>Variable renaming</h4>

When generating code, it is often the case that references to variables outside generated are made. In certain situations, intentional dynamic scoping can interfere with this. Converge thus allows variables to be declared as being renamed in a scope. When a variable is renamed, the previous name is removed from the scope, and the renamed name is implicitly nonlocal to the scope. For example in the following code, calling <code>f</code> will result in the outer <code>x</code> being incremented by 2; the <code>x</code> defined in <code>f</code> is local to <code>f</code> itself.
<pre>
x := 2

func f():
  rename x as y
  x := 3
  y += 2
</pre>
The <code>rename</code> declaration is typically only used in quasi-quoted code. Note that the <code>rename</code> and <code>nonlocal</code> declarations must be declared before any expressions in a function body.


<hr>


<h2>The <code>CEI</code> interface</h2>

At various points when compile-time meta-programming, one needs to interact with the compiler. The <code>CEI</code> package is the officially sanctioned interface to the Compiler, and can be imported with <code>import CEI</code>. Accessing the compiler internals in any other way may lead to future incompatibilities or undefined behaviour. The <a href="/documentation/current/modules_html/CEI.html">complete CEI module documentation can is available online</a>.


<h3>When quasi-quotes are not enough</h3>

Some ITree's can not practically be created using quasi-quotes. For example an <code>if</code> statement with multiple <code>elif</code> clauses has no obvious concrete syntax equivalent. In such cases the <code>CEI</code> interface presents a more traditional meta-programming interface to the user that allows ITree's that are not expressible via quasi-quotes to be built. Each ITree element has a corresponding function with a lower case name and a prepended `i' in the <code>CEI</code> interface e.g. <code>ivar</code>.


<h3>Names</h3>

We saw earlier that the Converge compiler sometimes uses names for variables that the user can not specify using concrete syntax.

<p>Users can generate their own <q>fresh</q> names - that is names that are guaranteed to clash with other normal or fresh names - using the <code>fresh_name</code> function. This takes an optional argument <code><em>x</em></code> which, if present, is incorporated into the generated name whilst still guaranteeing the uniqueness of the resulting name; this feature aids debugging by allowing the user to trace the origins of a fresh name.

<p>All fresh names begin with <code>$$</code>, and subverting the fresh name interface by manually creating variables beginning with the same prefix leads to undefined behaviour.


<h3>Lifting values</h3>

When meta-programming, one often needs to take a normal Converge value (e.g. a string) and obtain its ITree equivalent: this is known as <em>lifting</em> a value. The <code>lift</code> function in the <code>CEI</code> module lifts built-in datatypes such as strings into their ITree equivalents. Container types such as lists are recursively converted into their ITree equivalent.


<hr>


<h2>Example: A compile-time version of <code>printf</code></h2>

This section uses the example of generating a function for a simplified <code>printf</code> style function. This function takes a format string such as <code>"%s has %d %s"</code> and returns a quasi-quoted function which takes an argument per <q>%</q> specifier and intermingles that argument with the main text string. For the purposes of this section, we deal only with decimal numbers <code>%d</code> and strings <code>%s</code>.

<p>This example assumes the existence of a function <code>split_format</code> which given a string such as <code>"%s has %d %s"</code> returns a list of the form <code>[PRINTF_STRING, " has ", PRINTF_INT, " ", PRINTF_STRING]</code> where <code>PRINTF_STRING</code> and <code>PRINTF_INT</code> are constants. The full code can be found for this example, including for <code>split_format</code> can be found in the <code>examples/compile_time</code> directory in the Converge distribution.

<p>First we define the main <code>printf</code> function which creates the appropriate number of parameters for the format string (of the form <code>p0</code>, <code>p1</code> etc.). Parameters must be created by the <code>CEI</code> interface. An <code>iparam</code> has two components: a variable, and a default value (the latter can be set to <code>null</code> to signify the parameter is mandatory and has no default value). <code>printf</code> then returns an anonymous quasi-quoted function which contains the parameters, and a spliced-in expression returned by <code>simple_printf_expr</code>:

<pre>
func simple_printf(format):
  split := split_format(format)

  params := []
  i := 0
  for part := split.iter():
    if part == PRINTF_INT | part == PRINTF_STRING:
      params.append(CEI::iparam(CEI::ivar("p" + i.to_str()), null))
      i += 1

  return [|
    func ($c{params}):
      return $c{simple_printf_expr(split, 0)}
  |]
</pre>

Note the use of an insertion <code>(${params})</code> of a list of parameters into the anonymous function.

<p><code>simple_printf_expr</code> is a recursive function which turns a list such as <code>[PRINTF_INT, ": ", PRINTF_STRING]</code> into an expression along the lines of <code>p0.to_str + ": " + p1</code>:

<pre>
func simple_printf_expr(split, param_i):
  if split.len() == 0:
    return [| "" |]

  param := CEI::ivar("p" + param_i.to_str())
  if Builtins::String.conformed_by(split[0]):
    return [| $c{CEI::lift(split[0])} + $c{simple_printf_expr(split[1 : ], param_i)} |]
  elif split[0] == PRINTF_INT:
    return [| $c{param}.to_str() + $c{simple_printf_expr(split[1 : ], param_i + 1)} |]
  elif split[0] == PRINTF_STRING:
    return [| $c{param} + $c{simple_printf_expr(split[1 : ], param_i + 1)} |]
</pre>

For the input <code>%s has %d %s</code> the following ITree is created:

<pre>
func (p0, p1, p2):
  return p0 + " has " + p1.to_str() + " " + p2 + ""
</pre>

Of course, what we see here is not the ITree itself; rather we see a pretty printed concrete syntax version of the ITree. ITree's can be converted into a string representation with the <code>CEI::itree_format</code> function.


<hr>


<h2>Valid splice and insertion locations</h2>

Splices and inserts can appear at various locations, with different restrictions on what they are expected to return. The valid locations, and expected return types of a splice or insert, are as follows:

<table cellpadding="0" style="margin: 10px 10px 0 10px">
<tr>
<td colspan="3">
<hr style="padding: 0; margin: 0">
</td>
</tr>
<tr style="font-weight: bold">
<td>Location</td>
<td>Example(s)</td>
<td style="padding-left: 20px">Description</td>
</tr>
<tr>
<td colspan="3">
<hr style="padding: 0; margin: 0">
</td>
</tr>

<tr>
<td valign="top">Block-level expression</td>
<td valign="top"><pre style="padding-left: 0">x := ...
$<...>
f(x)</pre></td>
<td valign="top" style="padding-left: 20px">
A single IExpr, or list of IExpr's, can be spliced or inserted when an insert appears as a block-level expression (i.e. it is not a sub-expression).
</td>
</tr>

<tr>
<td valign="top"><q>Embedded</q> expression</td>
<td valign="top"><pre style="padding-left: 0">x := $<...> + 2</pre></td>
<td valign="top" style="padding-left: 20px">
An IExpr can be spliced or inserted anywhere a normal expression would be expected.
</td>
</tr>

<tr>
<td valign="top">Top-level definitions</td>
<td valign="top"><pre style="padding-left: 0">import X
$<...>
</pre></td>
<td valign="top" style="padding-left: 20px">
A single IClass_Def, IFunc_Def, IAssignment, or a list containing objects of these types can be spliced at the top-level of a file (since quasi-quotes can not appear at the top-level of a file, this particular type of splicing does not have an insertion equivalent).
</td>
</tr>

<tr>
<td valign="top">Class name</td>
<td valign="top"><pre style="padding-left: 0">class $<...>(...):
  ...
</pre></td>
<td valign="top" style="padding-left: 20px">
An IVar can be spliced or inserted for a class name.
</td>
</tr>

<tr>
<td valign="top">Class fields</td>
<td valign="top"><pre style="padding-left: 0">class C:
  $<...></pre></td>
<td valign="top" style="padding-left: 20px">
A single IAssignment or IFunc_Def, or a list containing objects of these types, can be spliced or inserted when an insert appears as a class field.
</td>
</tr>


<tr>
<td valign="top">Function name</td>
<td valign="top"><pre style="padding-left: 0">func $<...>(...):
  ...
</pre></td>
<td valign="top" style="padding-left: 20px">
An IVar can be spliced or inserted for a function name.
</td>
</tr>

<tr>
<td valign="top">Function parameter(s)</td>
<td valign="top"><pre style="padding-left: 0">func f($<...>):
  ...
</pre></td>
<td valign="top" style="padding-left: 20px">
A single IParam, or list of IParams, can be spliced or inserted into a functions parameters list.
</td>
</tr>

<tr>
<td valign="top">Rename(s)</td>
<td valign="top"><pre style="padding-left: 0">rename $<...></pre></td>
<td valign="top" style="padding-left: 20px">
A single IRename, or list of IRenames, can be spliced or inserted into a list of renames.
</td>
</tr>

<tr>
<td valign="top">Module lookup</td>
<td valign="top"><pre style="padding-left: 0">Module::$<...></pre></td>
<td valign="top" style="padding-left: 20px">
An IVar can be spliced or inserted for a definition to be looked-up in a module.
</td>
</tr>

<tr>
<td valign="top">Slot lookup</td>
<td valign="top"><pre style="padding-left: 0">o.$<...></pre></td>
<td valign="top" style="padding-left: 20px">
A string can be spliced or inserted for a slot name to be looked-up in an object.
</td>
</tr>

<tr>
<td valign="top">Assignment target(s)</td>
<td valign="top"><pre style="padding-left: 0">$<...> := ...</pre></td>
<td valign="top" style="padding-left: 20px">
An IVar, IGet, ISlot_Lookup, or a list containing objects of these types, can be spliced or inserted for the targets of an assignment.
</td>
</tr>
<tr>
<td colspan="3">
<hr style="padding: 0; margin: 0">
</td>
</tr>
</table>


<hr>


<h2>Example: Generating an arbitrary number of functions</h2>

Many libraries provide large numbers of near-identical functions to users. For example an HTML library may provide a function for each HTML element, whose job is to create a new object of the matching name. Typically creating each of these functions is an error-prone cut and paste task. With CTMP we can easily generate an arbitrary number of such functions. Using an insertion of a function name we can create quasi-quoted functions whose names are not known statically:
<pre>
name := "..."
[|
  func $c{CEI::ivar(name)}():
    ..
|]  
</pre>
Note that the resulting function's name will be dynamically scoped. Since we can splice lists of ITrees in at various locations, it then becomes trivial to generate multiple such functions. Let's take a simple example of a function which should generate a list of ITree functions which should print the name of the function when executed:
<pre>
func pfuncs(names):
  funcs := []
  for name := names.iter():  
    funcs.append([|
      func $c{CEI::ivar(name)}():
        Sys::println(${CEI::istring(name)})
    |])
  
  return funcs
</pre>
We can then use this function in a module as follows:
<pre>
$c&lt;pfuncs(["dog", "cat", "mouse"])&gt;

func main():
  dog()
  cat()
</pre>
Running this module will print out <q>dog</q> and <q>cat</q>.


<hr>


<h2>Src infos</h2>

Src infos are Converge's way of passing around and storing information relating bytecode instructions to the source code location that generated that bytecode. The src info concept is used uniformly throughout the Converge parser, compiler, and VM. A src info is a tuple <code>[&lt;<em>file name</em>&gt;, &lt;<em>char offset</em>&gt;]</code>; src infos are lists of these tuples. The special variable <code>__SRC_INFO__</code> returns src infos that pinpoint the first character of the variable name.

<p>When an ITree is built with quasi-quotes, it automatically picks up the src infos of the file and location of the quasi-quote. Extra src infos can be added using the following syntax:

<pre>[&lt;<em>expr</em>&gt;| ... |]</pre>

Calling ITree creation functions in the CEI module automatically adds src infos relating the caller to the ITree. i.e. <code>CEI::i<em>x(...)</em></code> is roughly equivalent to <code>ITree::I<em>x.new(..., __SRC_INFOS__)</em></code>.

<hr>


<h2>DSL blocks</h2>

A DSL can be embedded into a Converge source file via a <em>DSL block</em>. Such a block is introduced by a variant on the splice syntax <code>$&lt;&lt;...&gt;&gt;</code> where <code><em>expr</em></code> should evaluate to a function (the <em>DSL implementation function</em>). Note that, as with normal splices, the default action of a DSL splice is to ensure that no variable capture can occur; both capturing DSL splices <code>$c&lt;&lt;...&gt;&gt;</code> and pragma DSL splices <code>$p&lt;&lt;...&gt;&gt;</code> are available.

<p>The DSL implementation function is called at compile-time with a string representing the DSL block, and is expected to return an AST which will replace the DSL block in the same way as a normal splice. Compile-time meta-programming is thus the mechanism which facilitates embedding DSLs. Colloquially one uses the DSL implementation function to talk about the DSL block as being `an <em>expr</em> block'.

<p>An example of a DSL block and DSL implementation function is as follows:

<pre>
func dslim(dsl_block, src_infos):
  return ...

$&lt;&lt;dslim&gt;&gt;:
  ...
</pre>

Typically the DSL implementation uses the <a href="/documentation/current/modules_html/Compiler.CEI.html#dsl_parse"><code>CEI::dsl_parse</code></a> convenience function to parse the DSL block.


<hr>

<h2>Inserting ITrees which may capture</h2>

A tricky problem is embedding an ITree which may wish to intentionally capture variables in the scope it is spliced into, not the ITree it is inserted into. If dynamically scoped variables are used within the ITree being embedded into, problems can occur - this happens frequently with DSLs. The <code>CEI::embeddable_itree</code> function can be used to solve this problem. It takes in an ITree, and returns a copy with all free and bound variables to fresh names; usefully it also returns a list of IRenames which can be spliced in at the outermost-embedding level to ensure that the capturing. A typical use of this is as follows:
<pre>
renames, embeddable_cit := CEI::embeddable_itree(cit)
return [|
    func () {
        rename $c{renames}
        $c{embeddable_cit}
    }()
|]
</pre>


<hr>

<h2>Further reading</h2>

Examples of compile-time meta-programming with accompanying discussion can be found in the Converge distribution.

</%text>

<!--#include virtual="../../../footer.inc" -->
